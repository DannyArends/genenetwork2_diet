// Generated by CoffeeScript 1.6.1
(function() {
  var Manhattan_Plot, root,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  Manhattan_Plot = (function() {

    function Manhattan_Plot(plot_height, plot_width) {
      var _ref;
      this.plot_height = plot_height != null ? plot_height : 600;
      this.plot_width = plot_width != null ? plot_width : 1200;
      this.qtl_results = js_data.qtl_results;
      console.log("qtl_results are:", this.qtl_results);
      this.chromosomes = js_data.chromosomes;
      console.log("chromosomes are:", this.chromosomes);
      this.total_length = 0;
      this.max_chr = this.get_max_chr();
      this.x_coords = [];
      this.y_coords = [];
      this.marker_names = [];
      console.time('Create coordinates');
      this.get_qtl_count();
      this.create_coordinates();
      console.log("@x_coords: ", this.x_coords);
      console.log("@y_coords: ", this.y_coords);
      console.timeEnd('Create coordinates');
      _ref = this.get_chr_lengths(), this.chr_lengths = _ref[0], this.cumulative_chr_lengths = _ref[1];
      this.x_buffer = this.plot_width / 30;
      this.y_buffer = this.plot_height / 20;
      this.x_max = this.total_length;
      console.log("@x_max: ", this.x_max);
      console.log("@x_buffer: ", this.x_buffer);
      this.y_max = d3.max(this.y_coords) * 1.2;
      this.y_threshold = this.get_lod_threshold();
      this.svg = this.create_svg();
      console.log("svg created");
      this.plot_coordinates = _.zip(this.x_coords, this.y_coords, this.marker_names);
      console.log("coordinates:", this.plot_coordinates);
      this.plot_height -= this.y_buffer;
      this.create_scales();
      console.time('Create graph');
      this.create_graph();
      console.timeEnd('Create graph');
    }

    Manhattan_Plot.prototype.get_max_chr = function() {
      var chr, max_chr, result, _i, _len, _ref;
      max_chr = 0;
      _ref = this.qtl_results;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        result = _ref[_i];
        chr = parseInt(result.chr);
        if (!_.isNaN(chr)) {
          if (chr > max_chr) {
            max_chr = chr;
          }
        }
      }
      return max_chr;
    };

    Manhattan_Plot.prototype.get_chr_lengths = function() {
      /*
      #Gets a list of both individual and cumulative (the position of one on the graph
      #is its own length plus the lengths of all preceding chromosomes) lengths in order
      #to draw the vertical lines separating chromosomes and the chromosome labels
      #
      */

      var chr_lengths, cumulative_chr_lengths, key, this_length, total_length;
      cumulative_chr_lengths = [];
      chr_lengths = [];
      total_length = 0;
      for (key in this.chromosomes) {
        this_length = this.chromosomes[key];
        chr_lengths.push(this_length);
        cumulative_chr_lengths.push(total_length + this_length);
        total_length += this_length;
      }
      console.log("chr_lengths: ", chr_lengths);
      return [chr_lengths, cumulative_chr_lengths];
    };

    Manhattan_Plot.prototype.get_qtl_count = function() {
      var high_qtl_count, result, _i, _len, _ref;
      high_qtl_count = 0;
      _ref = js_data.qtl_results;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        result = _ref[_i];
        if (result.lod_score > 1) {
          high_qtl_count += 1;
        }
      }
      console.log("high_qtl_count:", high_qtl_count);
      if (high_qtl_count > 10000) {
        return this.y_axis_filter = 2;
      } else if (high_qtl_count > 1000) {
        return this.y_axis_filter = 1;
      } else {
        return this.y_axis_filter = 0;
      }
    };

    Manhattan_Plot.prototype.create_coordinates = function() {
      var chr_length, chr_lengths, chr_seen, result, _i, _len, _ref, _ref1;
      chr_lengths = [];
      chr_seen = [];
      _ref = js_data.qtl_results;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        result = _ref[_i];
        if (result.chr === "X") {
          chr_length = parseFloat(this.chromosomes[13]);
        } else {
          chr_length = parseFloat(this.chromosomes[result.chr]);
        }
        console.log("chr_seen is", chr_seen);
        if (!(_ref1 = result.chr, __indexOf.call(chr_seen, _ref1) >= 0)) {
          chr_seen.push(result.chr);
          chr_lengths.push(chr_length);
          console.log("result.chr:", result.chr);
          console.log("total_length:", this.total_length);
          if (parseInt(result.chr) !== 1) {
            console.log("plus:", chr_lengths.length - 2);
            console.log("chr_lengths.length", chr_lengths.length);
            this.total_length += parseFloat(chr_lengths[chr_lengths.length - 2]);
          }
        }
        if (result.lod_score > this.y_axis_filter) {
          this.x_coords.push(this.total_length + parseFloat(result.Mb));
          this.y_coords.push(result.lod_score);
          this.marker_names.push(result.name);
        }
      }
      return this.total_length += parseFloat(chr_lengths[chr_lengths.length - 1]);
    };

    Manhattan_Plot.prototype.show_marker_in_table = function(marker_info) {
      var marker_name;
      console.log("in show_marker_in_table");
      /* Searches for the select marker in the results table below
      */

      if (marker_info) {
        marker_name = marker_info[2];
        return $("#qtl_results_filter").find("input:first").val(marker_name).change();
      }
    };

    Manhattan_Plot.prototype.create_svg = function() {
      var svg;
      svg = d3.select("#manhattan_plot").append("svg").attr("class", "manhattan_plot").attr("width", this.plot_width + this.x_buffer).attr("height", this.plot_height + this.y_buffer).append("g");
      return svg;
    };

    Manhattan_Plot.prototype.create_graph = function() {
      this.add_border();
      this.add_x_axis();
      this.add_y_axis();
      this.add_axis_labels();
      this.add_chr_lines();
      this.fill_chr_areas();
      this.add_chr_labels();
      return this.add_plot_points();
    };

    Manhattan_Plot.prototype.add_border = function() {
      var border_coords,
        _this = this;
      border_coords = [[this.y_buffer, this.plot_height, this.x_buffer, this.x_buffer], [this.y_buffer, this.plot_height, this.plot_width, this.plot_width], [this.y_buffer, this.y_buffer, this.x_buffer, this.plot_width], [this.plot_height, this.plot_height, this.x_buffer, this.plot_width]];
      return this.svg.selectAll("line").data(border_coords).enter().append("line").attr("y1", function(d) {
        return d[0];
      }).attr("y2", function(d) {
        return d[1];
      }).attr("x1", function(d) {
        return d[2];
      }).attr("x2", function(d) {
        return d[3];
      }).style("stroke", "#000");
    };

    Manhattan_Plot.prototype.create_scales = function() {
      if ('24' in this.chromosomes) {
        console.log("@chromosomes[24]:", this.chromosomes['24']);
        console.log("@chromosomes[23]:", this.chromosomes['23']);
        console.log("@total_length:", this.total_length);
        console.log("d3.max(@xcoords):", d3.max(this.x_coords));
        this.x_scale = d3.scale.linear().domain([0, this.total_length + this.chromosomes['24']]).range([this.x_buffer, this.plot_width]);
      } else {
        this.x_scale = d3.scale.linear().domain([0, this.total_length + this.chromosomes['20']]).range([this.x_buffer, this.plot_width]);
      }
      return this.y_scale = d3.scale.linear().domain([this.y_axis_filter, this.y_max]).range([this.plot_height, this.y_buffer]);
    };

    Manhattan_Plot.prototype.create_x_axis_tick_values = function() {
      var chr_ticks, i, length, tick, tick_count, tick_val, tick_vals, val, _i, _j, _k, _len, _ref, _ref1, _ref2;
      tick_vals = [];
      for (val = _i = 25, _ref = this.cumulative_chr_lengths[0]; 25 <= _ref ? _i <= _ref : _i >= _ref; val = 25 <= _ref ? ++_i : --_i) {
        if (val % 25 === 0) {
          tick_vals.push(val);
        }
      }
      _ref1 = this.cumulative_chr_lengths;
      for (i = _j = 0, _len = _ref1.length; _j < _len; i = ++_j) {
        length = _ref1[i];
        if (i === 0) {
          continue;
        }
        chr_ticks = [];
        tick_count = Math.floor(this.chr_lengths[i] / 25);
        tick_val = parseInt(this.cumulative_chr_lengths[i - 1]);
        for (tick = _k = 0, _ref2 = tick_count - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; tick = 0 <= _ref2 ? ++_k : --_k) {
          tick_val += 25;
          chr_ticks.push(tick_val);
        }
        Array.prototype.push.apply(tick_vals, chr_ticks);
      }
      return tick_vals;
    };

    Manhattan_Plot.prototype.add_x_axis = function() {
      var next_chr, tmp_tick_val,
        _this = this;
      this.xAxis = d3.svg.axis().scale(this.x_scale).orient("bottom").tickValues(this.create_x_axis_tick_values());
      next_chr = 1;
      tmp_tick_val = 0;
      this.xAxis.tickFormat(function(d) {
        var next_chr_length, tick_val;
        d3.format("d");
        if (d < _this.cumulative_chr_lengths[0]) {
          tick_val = d;
        } else {
          next_chr_length = _this.cumulative_chr_lengths[next_chr];
          if (d > next_chr_length) {
            next_chr += 1;
            tmp_tick_val = 25;
            tick_val = tmp_tick_val;
          } else {
            tmp_tick_val += 25;
            tick_val = tmp_tick_val;
          }
        }
        return tick_val;
      });
      return this.svg.append("g").attr("class", "x_axis").attr("transform", "translate(0," + this.plot_height + ")").call(this.xAxis).selectAll("text").attr("text-anchor", "right").attr("dx", "-1.6em").attr("transform", function(d) {
        return "translate(-12,0) rotate(-90)";
      });
    };

    Manhattan_Plot.prototype.add_y_axis = function() {
      this.yAxis = d3.svg.axis().scale(this.y_scale).orient("left").ticks(5);
      return this.svg.append("g").attr("class", "y_axis").attr("transform", "translate(" + this.x_buffer + ",0)").call(this.yAxis);
    };

    Manhattan_Plot.prototype.add_axis_labels = function() {
      return this.svg.append("text").attr("transform", "rotate(-90)").attr("y", 0 - (this.plot_height / 2)).attr("x", this.x_buffer).attr("dy", "1em").style("text-anchor", "middle").text("LOD Score");
    };

    Manhattan_Plot.prototype.add_chr_lines = function() {
      var _this = this;
      return this.svg.selectAll("line").data(this.cumulative_chr_lengths, function(d) {
        return d;
      }).enter().append("line").attr("x1", this.x_scale).attr("x2", this.x_scale).attr("y1", this.y_buffer).attr("y2", this.plot_height).style("stroke", "#ccc");
    };

    Manhattan_Plot.prototype.fill_chr_areas = function() {
      var _this = this;
      console.log("cumu_chr_lengths:", this.cumulative_chr_lengths);
      console.log("example:", this.x_scale(this.cumulative_chr_lengths[0]));
      return this.svg.selectAll("rect.chr_fill_area").data(_.zip(this.chr_lengths, this.cumulative_chr_lengths), function(d) {
        return d;
      }).enter().append("rect").attr("x", function(d, i) {
        return _this.x_scale(d[1] - d[0]);
      }).attr("y", this.y_buffer + 2).attr("width", function(d, i) {
        var ending, starting, width;
        starting = _this.x_scale(d[1] - d[0]);
        ending = _this.x_scale(_this.cumulative_chr_lengths[i]);
        width = ending - starting;
        console.log("width:", d[0]);
        return width;
      }).attr("height", this.plot_height - this.y_buffer - 3).attr("fill", function(d, i) {
        if ((i + 1) % 2) {
          return "none";
        } else {
          return "whitesmoke";
        }
      });
    };

    Manhattan_Plot.prototype.add_chr_labels = function() {
      var chr_info, chr_names, key,
        _this = this;
      chr_names = [];
      for (key in this.chromosomes) {
        chr_names.push(key);
      }
      chr_info = _.zip(chr_names, this.chr_lengths, this.cumulative_chr_lengths);
      return this.svg.selectAll("text").data(chr_info, function(d) {
        return d;
      }).enter().append("text").attr("class", "chr_label").text(function(d) {
        if (d[0] === "23") {
          return "X";
        } else if (d[0] === "24") {
          return "X/Y";
        } else {
          return d[0];
        }
      }).attr("x", function(d) {
        return _this.x_scale(d[2] - d[1] / 2);
      }).attr("y", this.plot_height * 0.1).attr("dx", "0em").attr("text-anchor", "middle").attr("font-family", "sans-serif").attr("font-size", "18px").attr("cursor", "pointer").attr("fill", "black").on("click", function(d) {
        var this_chr;
        this_chr = d;
        return _this.redraw_plot(d);
      });
    };

    Manhattan_Plot.prototype.add_plot_points = function() {
      var _this = this;
      return this.plot_point = this.svg.selectAll("circle").data(this.plot_coordinates).enter().append("circle").attr("cx", function(d) {
        return _this.x_scale(d[0]);
      }).attr("cy", function(d) {
        return _this.y_scale(d[1]);
      }).attr("r", function(d) {
        if (d[1] > 2) {
          return 3;
        } else {
          return 2;
        }
      }).attr("fill", function(d) {
        if (d[1] > 2) {
          return "white";
        } else {
          return "black";
        }
      }).attr("stroke", "black").attr("stroke-width", "1").attr("id", function(d) {
        return "point_" + String(d[2]);
      }).classed("circle", true).on("mouseover", function(d) {
        var this_id;
        console.log("d3.event is:", d3.event);
        console.log("d is:", d);
        this_id = "point_" + String(d[2]);
        return d3.select("#" + this_id).classed("d3_highlight", true).attr("r", 5).attr("stroke", "none").attr("fill", "blue").call(_this.show_marker_in_table(d));
      }).on("mouseout", function(d) {
        var this_id;
        this_id = "point_" + String(d[2]);
        return d3.select("#" + this_id).classed("d3_highlight", false).attr("r", function(d) {
          if (d[1] > 2) {
            return 3;
          } else {
            return 2;
          }
        }).attr("fill", function(d) {
          if (d[1] > 2) {
            return "white";
          } else {
            return "black";
          }
        }).attr("stroke", "black").attr("stroke-width", "1");
      }).append("svg:title").text(function(d) {
        return d[2];
      });
    };

    Manhattan_Plot.prototype.redraw_plot = function(chr_ob) {
      console.log("chr_name is:", chr_ob[0]);
      console.log("chr_length is:", chr_ob[1]);
      $('#manhattan_plot').remove();
      $('#manhattan_plot_container').append('<div id="manhattan_plot"></div>');
      return root.chr_plot = new Chr_Manhattan_Plot(600, 1200, chr_ob);
    };

    Manhattan_Plot.prototype.create_zoom_pane = function() {
      var zoom;
      zoom = d3.behavior.zoom().on("zoom", draw);
      return this.svg.append("rect").attr("class", "pane").attr("width", this.plot_width).attr("height", this.plot_height).call(zoom);
    };

    Manhattan_Plot.prototype.draw = function() {
      this.svg.select("g.x_axis").call(this.xAxis);
      this.svg.select("g.y_axis").call(this.yAxis);
      this.svg.select("path.area").attr("d", area);
      return this.svg.select("path.line").attr("d", line);
    };

    return Manhattan_Plot;

  })();

  root.Manhattan_Plot = Manhattan_Plot;

  new Manhattan_Plot(600, 1200);

}).call(this);
